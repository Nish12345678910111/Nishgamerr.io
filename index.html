<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Supabase — user_ips row creator (full speed, log controls)</title>
  <style>
    /* GUI preserved exactly (layout + controls unchanged) */
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 20px; background:#f7f7fb; color:#111 }
    .card { background:white; padding:18px; border-radius:10px; box-shadow: 0 6px 18px rgba(20,20,50,0.06); max-width:900px; margin:auto }
    h1 { margin:0 0 14px 0; font-size:20px }
    label { display:block; margin-top:10px; font-size:13px }
    input[type="number"], input[type="text"], select { padding:8px 10px; border-radius:8px; border:1px solid #e2e6ef; width:140px }
    .row { display:flex; gap:12px; align-items:center; margin-top:12px; flex-wrap:wrap }
    button { padding:10px 14px; border-radius:8px; border: none; cursor:pointer; font-weight:600 }
    button.primary { background:#2563eb; color:white }
    button.warn { background:#ef4444; color:white }
    button.ghost { background:#eef2ff; color:#0f172a }
    pre { background:#0b1220; color:#dbeafe; padding:12px; border-radius:8px; max-height:260px; overflow:auto; margin-top:14px; white-space:pre-wrap }
    .meta { margin-top:10px; font-size:13px; color:#374151 }
    .counters { margin-top:10px; display:flex; gap:12px; font-size:13px }
    .small { font-size:12px; color:#6b7280 }
    .danger { color:#b91c1c; font-weight:700 }
  </style>
</head>
<body>
  <div class="card" role="main" aria-labelledby="main-title">
    <h1 id="main-title">Supabase — user_ips row creator (full speed, log controls)</h1>

    <div class="row">
      <button id="createSingle" class="primary">Create once</button>
      <button id="startBtn" class="ghost">Start</button>
      <button id="stopBtn" class="warn">Stop</button>
      <label class="small" style="margin-left:8px">Status: <span id="status">idle</span></label>
    </div>

    <div style="display:flex; gap:18px; margin-top:12px; flex-wrap:wrap">
      <div>
        <label>Interval (ms)</label>
        <input id="intervalMs" type="number" min="0" value="500" />
      </div>
      <div>
        <label>Max rows (0 = infinite)</label>
        <input id="maxRows" type="number" min="0" value="0" />
      </div>
      <div>
        <label>Max username / letters length (1–20)</label>
        <input id="maxLetters" type="number" min="1" max="20" value="12" />
      </div>
      <div>
        <label>Max num value (>=0)</label>
        <input id="maxNum" type="number" min="0" value="9999" />
      </div>
    </div>

    <div class="meta">
      Table: <code>user_ips</code>. Script auto-detects schema by probing and will:
      <ul style="margin:6px 0 0 18px; padding:0">
        <li>Prefer inserting into <code>username</code> &amp; <code>current_username</code> (same generated username into both).</li>
        <li>Also attempts to set <code>status</code> = <code>'offline'</code> on each insert when that column exists (or will optimistically include it and remove if missing).</li>
        <li>If username/current don't exist, prefers <code>letters</code> &amp; <code>num</code> to preserve earlier behavior.</li>
        <li>No DDL (CREATE/ALTER) is executed from this page.</li>
      </ul>
    </div>

    <div class="counters">
      <div>Inserted: <strong id="inserted">0</strong></div>
      <div>Errors: <strong id="errors">0</strong></div>
      <div>Attempts: <strong id="attempts">0</strong></div>
    </div>

    <pre id="log" aria-live="polite">Log output will appear here.</pre>

    <div class="small" style="margin-top:10px">
      Behavior additions: on <strong>Start</strong> the script will clear the log if it contains &gt;= 500 lines (old 500 clears). During runtime the log auto-clears when it grows above 200 lines to prevent browser lag.  
      Interval = 0 (full speed) runs the insert loop in high-concurrency "full speed" mode as you requested. Use responsibly.
    </div>
  </div>

  <!-- Supabase JS (ESM) -->
  <script type="module">
    import { createClient } from 'https://cdn.skypack.dev/@supabase/supabase-js@2'

    // ----- Supabase values (unchanged) -----
    const SUPABASE_URL = 'https://xvnbxdcqmfsnnvbugasi.supabase.co'
    const SUPABASE_KEY = 'sb_publishable_OQbzgO3ZE6-6qDl1YT_fXA_LA5aM-f0'
    const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)

    // ----- DOM -----
    const createSingle = document.getElementById('createSingle')
    const startBtn = document.getElementById('startBtn')
    const stopBtn = document.getElementById('stopBtn')
    const logEl = document.getElementById('log')
    const statusEl = document.getElementById('status')
    const insertedEl = document.getElementById('inserted')
    const errorsEl = document.getElementById('errors')
    const attemptsEl = document.getElementById('attempts')

    const intervalInput = document.getElementById('intervalMs')
    const maxRowsInput = document.getElementById('maxRows')
    const maxLettersInput = document.getElementById('maxLetters')
    const maxNumInput = document.getElementById('maxNum')

    let intervalId = null
    let inserted = 0
    let errors = 0
    let attempts = 0
    let running = false
    let runCount = 0
    let fullSpeedWorkerRunning = false

    // ----- Candidate name lists (expanded) -----
    const usernameCandidates = ['username','user_name','name','user','uname']
    const currentCandidates = ['current_username','currentuser','current_name','currentusername','current_user']
    const lettersCandidates = ['letters','letter','txt','text','message']
    const numCandidates = ['num','number','value','count','n']
    const statusCandidates = ['status','state','user_status','current_status']

    // Detected existing columns (will be set by probe)
    const detected = {
      username: null,
      current: null,
      letters: null,
      num: null,
      status: null
    }

    // ----- Logging helpers -----
    function clearLog() {
      logEl.textContent = ''
    }

    function getLogLineCount() {
      // count non-empty lines
      const raw = logEl.textContent || ''
      if (!raw) return 0
      return raw.split('\n').filter(l => l.trim() !== '').length
    }

    function trimLogIfNeeded() {
      // if >200 lines, clear all to avoid lag (user requested)
      const lines = getLogLineCount()
      if (lines > 200) {
        // clear all
        clearLog()
        appendLog(`[autoclear] Log exceeded 200 lines — cleared to avoid browser lag.`)
      }
    }

    function appendLog(msg) {
      // Before appending, if log is already large (>=200) clear it
      const lines = getLogLineCount()
      if (lines >= 200) {
        // clear all before adding the new one
        logEl.textContent = ''
        // show the clearing message first
        const time0 = new Date().toLocaleTimeString()
        logEl.textContent = `[${time0}] [autoclear] Log exceeded 200 lines — cleared.\n`
      }
      const time = new Date().toLocaleTimeString()
      logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent
    }

    // On start: if old logs >= 500 lines, clear all old logs (user requested)
    function clearOld500IfNeeded() {
      const lines = getLogLineCount()
      if (lines >= 500) {
        clearLog()
        appendLog('[startup clear] Log had >=500 lines — cleared old logs on Start.')
      }
    }

    // ----- Random helpers -----
    function randomLetters(maxLen) {
      const letters = 'abcdefghijklmnopqrstuvwxyz'
      const len = Math.floor(Math.random() * maxLen) + 1
      let s = ''
      for (let i = 0; i < len; i++) s += letters.charAt(Math.floor(Math.random() * letters.length))
      return s
    }

    function randomNum(max) {
      return Math.floor(Math.random() * (Number(max) + 1))
    }

    // ----- Probing columns (safe SELECT) -----
    async function probeColumn(col) {
      try {
        const { data, error } = await supabase
          .from('user_ips')
          .select(`${col}`)
          .limit(1)
        if (error) return false
        return true
      } catch (err) {
        return false
      }
    }

    async function detectAllColumns() {
      appendLog('Probing columns (this may take a moment)...')

      for (const c of usernameCandidates) {
        if (await probeColumn(c)) {
          detected.username = c
          appendLog(`Detected username column: ${c}`)
          break
        }
      }

      for (const c of currentCandidates) {
        if (await probeColumn(c)) {
          detected.current = c
          appendLog(`Detected current_username column: ${c}`)
          break
        }
      }

      for (const c of lettersCandidates) {
        if (await probeColumn(c)) {
          detected.letters = c
          appendLog(`Detected letters-like column: ${c}`)
          break
        }
      }

      for (const c of numCandidates) {
        if (await probeColumn(c)) {
          detected.num = c
          appendLog(`Detected num-like column: ${c}`)
          break
        }
      }

      for (const c of statusCandidates) {
        if (await probeColumn(c)) {
          detected.status = c
          appendLog(`Detected status-like column: ${c}`)
          break
        }
      }

      if (!detected.username) appendLog('No username-like column detected (will try preferred names on insert).')
      if (!detected.current) appendLog('No current_username-like column detected (will try preferred names on insert).')
      if (!detected.letters) appendLog('No letters-like column detected (will try preferred names on insert).')
      if (!detected.num) appendLog('No num-like column detected (will try preferred names on insert).')
      if (!detected.status) appendLog('No status-like column detected (will optimistically include "status" key and remove if missing).')

      appendLog(`Detection finished — username:${detected.username||'NONE'} current:${detected.current||'NONE'} letters:${detected.letters||'NONE'} num:${detected.num||'NONE'} status:${detected.status||'NONE'}`)
    }

    // ----- Error parsing & adaptive removal -----
    function parseMissingColumnsFromError(msg) {
      if (!msg) return []
      const missing = []
      const re = /'([A-Za-z0-9_]+)'/g
      let m
      while ((m = re.exec(msg)) !== null) {
        const name = m[1]
        const lower = name.toLowerCase()
        const allCandidates = [...usernameCandidates, ...currentCandidates, ...lettersCandidates, ...numCandidates, ...statusCandidates, 'username','current_username','letters','num','status']
        if (allCandidates.includes(lower) || allCandidates.includes(name)) {
          missing.push(name)
        }
      }
      return Array.from(new Set(missing))
    }

    // ----- Payload building rules (same as before) -----
    function buildPayload(maxLetters, maxNum) {
      const payload = {}
      const genName = randomLetters(maxLetters)

      if (detected.username && detected.current && detected.username !== detected.current) {
        payload[detected.username] = genName
        payload[detected.current] = genName
        if (detected.status) payload[detected.status] = 'offline'
        else payload['status'] = 'offline'
        return payload
      }

      if (detected.username && (!detected.current || detected.username === detected.current)) {
        payload[detected.username] = genName
        if (!detected.current && detected.username !== 'current_username') payload['current_username'] = genName
        if (detected.status) payload[detected.status] = 'offline'
        else payload['status'] = 'offline'
        return payload
      }

      if (detected.current && !detected.username) {
        payload[detected.current] = genName
        if (detected.current !== 'username') payload['username'] = genName
        if (detected.status) payload[detected.status] = 'offline'
        else payload['status'] = 'offline'
        return payload
      }

      if (detected.letters && detected.num && detected.letters !== detected.num) {
        payload[detected.letters] = randomLetters(maxLetters)
        payload[detected.num] = randomNum(maxNum)
        if (detected.status) payload[detected.status] = 'offline'
        else payload['status'] = 'offline'
        return payload
      }

      // fallback: optimistic full payload
      payload['username'] = genName
      payload['current_username'] = genName
      payload['letters'] = randomLetters(maxLetters)
      payload['num'] = randomNum(maxNum)
      payload['status'] = 'offline'
      return payload
    }

    // Insert logic with adaptive retries (returns a promise)
    async function insertWithRetries(payload, retryLimit = 3) {
      let attempt = 0
      let currentPayload = { ...payload }

      while (attempt <= retryLimit) {
        attempt++
        try {
          const { data, error } = await supabase.from('user_ips').insert([currentPayload])
          if (error) {
            // parse missing columns and remove them
            const missing = parseMissingColumnsFromError(error.message || '')
            if (missing.length > 0) {
              missing.forEach(col => {
                delete currentPayload[col]
                // update detected state if it matches
                if (detected.username && detected.username.toLowerCase() === col.toLowerCase()) detected.username = null
                if (detected.current && detected.current.toLowerCase() === col.toLowerCase()) detected.current = null
                if (detected.letters && detected.letters.toLowerCase() === col.toLowerCase()) detected.letters = null
                if (detected.num && detected.num.toLowerCase() === col.toLowerCase()) detected.num = null
                if (detected.status && detected.status.toLowerCase() === col.toLowerCase()) detected.status = null
              })
              appendLog(`Insert error encountered; removed missing columns: ${missing.join(', ')}; retrying (attempt ${attempt}/${retryLimit})`)
              if (Object.keys(currentPayload).length === 0) {
                // rebuild a minimal payload from remaining detection or preferred username
                const gen = randomLetters(Number(maxLettersInput.value) || 12)
                if (detected.username) currentPayload[detected.username] = gen
                else if (detected.current) currentPayload[detected.current] = gen
                else currentPayload['username'] = gen
                if (detected.status) currentPayload[detected.status] = 'offline'
              }
              continue
            } else {
              // other error (policy, permission, etc.) — return failure
              return { ok: false, error }
            }
          } else {
            // success
            return { ok: true, data }
          }
        } catch (err) {
          return { ok: false, error: err }
        }
      }
      return { ok: false, error: new Error('Retries exhausted') }
    }

    // Fire-and-forget insertion wrapper for full-speed batching.
    // It calls insertWithRetries and updates counters when the promise resolves.
    function fireInsert(payload) {
      // call but don't await here to allow concurrency
      insertWithRetries(payload, 2)
        .then(res => {
          if (res && res.ok) {
            inserted++
            insertedEl.textContent = inserted
            // log but keep log size controlled via appendLog which auto-clears when >200 lines
            appendLog(`Inserted (async) — keys: ${Object.keys(payload).join(', ')}`)
          } else {
            errors++
            errorsEl.textContent = errors
            appendLog(`Insert failed (async): ${res && res.error && res.error.message ? res.error.message : JSON.stringify(res && res.error)}`)
          }
        }).catch(err => {
          errors++
          errorsEl.textContent = errors
          appendLog('Insert exception (async): ' + (err && err.message ? err.message : String(err)))
        })
    }

    // Single insert used by Create once (awaits completion)
    async function insertOne() {
      attempts++
      attemptsEl.textContent = attempts
      const maxLetters = Math.max(1, Math.min(20, Number(maxLettersInput.value) || 12))
      const maxNum = Math.max(0, Number(maxNumInput.value) || 9999)
      const payload = buildPayload(maxLetters, maxNum)
      appendLog(`Attempting insert — initial payload keys: ${Object.keys(payload).join(', ')}`)
      const res = await insertWithRetries(payload, 3)
      if (res.ok) {
        inserted++
        insertedEl.textContent = inserted
        appendLog(`Insert successful — payload used: ${JSON.stringify(payload)}`)
      } else {
        errors++
        errorsEl.textContent = errors
        appendLog(`Final insert failure: ${res.error && res.error.message ? res.error.message : res.error}`)
      }
      trimLogIfNeeded()
      return res
    }

    // Full-speed loop: dispatches batches of concurrent fireInsert calls with micro-yields.
    async function runFullSpeedLoop() {
      fullSpeedWorkerRunning = true
      // choose a batch size; larger => more concurrent requests. User requested "full speed".
      // We'll use 100 concurrent inserts per micro-yield to push lots of requests quickly.
      const batchSize = 100
      appendLog('[full-speed] entering full-speed insertion mode (zero-interval).')
      try {
        while (running && fullSpeedWorkerRunning) {
          // respect maxRows if set
          const maxRows = Math.max(0, Number(maxRowsInput.value) || 0)
          if (maxRows > 0 && runCount >= maxRows) {
            stopLoop('Reached maxRows limit')
            break
          }

          // prepare batch
          for (let i = 0; i < batchSize && running; i++) {
            // each iteration is an "attempt"
            attempts++
            attemptsEl.textContent = attempts
            runCount++
            const maxLetters = Math.max(1, Math.min(20, Number(maxLettersInput.value) || 12))
            const maxNum = Math.max(0, Number(maxNumInput.value) || 9999)
            const payload = buildPayload(maxLetters, maxNum)
            fireInsert(payload) // fire-and-forget; counters updated by handler
            // if maxRows is finite, break when reached
            if (maxRows > 0 && runCount >= maxRows) break
          }

          // micro-yield to event loop so browser remains somewhat responsive
          // using Promise.resolve() provides a microtask yield
          await Promise.resolve()

          // control log size proactively
          trimLogIfNeeded()
        }
      } catch (err) {
        appendLog('[full-speed] worker exception: ' + (err && err.message ? err.message : String(err)))
      } finally {
        fullSpeedWorkerRunning = false
        appendLog('[full-speed] exited full-speed insertion mode.')
      }
    }

    // Interval-based loop (non-zero interval), uses setInterval
    function startIntervalLoop(intervalMs) {
      intervalId = setInterval(async () => {
        if (!running) return
        if (Number(intervalMs) === 0) return // safety; shouldn't happen
        const maxRows = Math.max(0, Number(maxRowsInput.value) || 0)
        if (maxRows > 0 && runCount >= maxRows) {
          stopLoop('Reached maxRows limit')
          return
        }
        runCount++
        await insertOne()
      }, intervalMs)
    }

    // ----- UI handlers (no GUI changes) -----
    createSingle.addEventListener('click', async () => {
      statusEl.textContent = 'creating...'
      await insertOne()
      statusEl.textContent = 'idle'
    })

    startBtn.addEventListener('click', async () => {
      if (running) { appendLog('Already running'); return }
      // On start: clear old 500 logs if needed
      clearOld500IfNeeded()

      const intervalMs = Math.max(0, Number(intervalInput.value) || 0) // allow 0
      const maxRows = Math.max(0, Number(maxRowsInput.value) || 0)

      running = true
      runCount = 0
      statusEl.textContent = 'running'
      appendLog(`Started (interval ${intervalMs} ms, maxRows ${maxRows === 0 ? 'INFINITE' : maxRows})`)

      // If zero interval -> full speed mode (user confirmed "yes full speed")
      if (intervalMs === 0) {
        // start full-speed worker
        runFullSpeedLoop()
      } else {
        startIntervalLoop(intervalMs)
      }
    })

    stopBtn.addEventListener('click', () => {
      if (!running) { appendLog('Not running'); return }
      stopLoop('Stopped by user')
    })

    function stopLoop(reason) {
      if (intervalId) {
        clearInterval(intervalId)
        intervalId = null
      }
      running = false
      fullSpeedWorkerRunning = false
      statusEl.textContent = 'stopped'
      appendLog(`Stopped: ${reason}`)
      // final trim to keep UI snappy
      trimLogIfNeeded()
    }

    // ----- Init: detect columns by probing table columns with safe SELECTs -----
    ;(async function init() {
      appendLog('Initializing — probing table columns (no DDL will be executed).')
      await detectAllColumns()
      // quick connectivity test
      try {
        const { data, error } = await supabase.from('user_ips').select('1').limit(1)
        if (error) appendLog('Connection test SELECT returned: ' + error.message)
        else appendLog('Connection test: OK (read)')
      } catch (err) {
        appendLog('Connection test exception: ' + (err.message || err))
      }
    })()
  </script>
</body>
</html>

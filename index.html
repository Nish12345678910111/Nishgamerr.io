<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat — Supabase (Realtime + Polling + Delete)</title>

<!-- Supabase client -->
<script type="module" src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm"></script>

<style>
  :root{
    --bg:#0b1220; --panel:#071127; --input:#0f1724; --accent:#60a5fa;
    --muted:#94a3b8; --btn:#2563eb; --err:#ef4444; --radius:8px;
  }
  body{background:var(--bg);color:#e6eef8;font-family:Inter,system-ui,Roboto,sans-serif;
    display:flex;justify-content:center;padding:20px;margin:0;}
  .wrap{width:100%;max-width:760px}
  h1{color:var(--accent);text-align:center;margin:0 0 12px}
  .top{display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:10px}
  #currentUsername{color:var(--muted)}
  #username{background:var(--input);color:inherit;border:1px solid #1f2937;padding:8px;border-radius:6px}
  #saveName{background:var(--btn);color:#fff;border:none;padding:8px 12px;border-radius:6px;cursor:pointer}
  #chat{background:var(--panel);border-radius:10px;padding:12px;height:420px;overflow:auto;border:1px solid #1f2937;margin-bottom:10px}
  .message{display:flex;align-items:center;gap:8px;padding:6px;border-radius:6px;background:transparent}
  .message .meta{color:var(--muted);font-size:0.75rem;white-space:nowrap}
  .username{color:var(--accent);font-weight:700;margin-right:6px}
  .text{flex:1;word-break:break-word}
  .tiny-del{width:16px;height:16px;border-radius:4px;background:var(--err);color:#fff;border:none;font-size:11px;cursor:pointer;flex-shrink:0}
  #controls{display:flex;gap:8px}
  #messageInput{flex:1;padding:10px;border-radius:8px;background:var(--input);border:1px solid #1f2937;color:inherit}
  #sendBtn{background:var(--btn);color:#fff;border:none;padding:10px 14px;border-radius:8px;cursor:pointer}
  .pending{opacity:.7;font-style:italic}
  .notice{color:#f59e0b;margin-bottom:8px}
  @media (max-width:600px){ #chat{height:300px} }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Modern Chat App</h1>
    <div class="top">
      <div>
        <span id="currentUsername">Username: Guest</span>
        <input id="username" placeholder="Enter username" />
        <button id="saveName">Save</button>
      </div>
      <div style="color:var(--muted)">Dark • Polling+Realtime</div>
    </div>

    <div id="notice" class="notice" style="display:none"></div>
    <div id="chat" role="log" aria-live="polite"></div>

    <div id="controls">
      <input id="messageInput" placeholder="Type a message" />
      <button id="sendBtn">Send</button>
    </div>
  </div>

<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

/* ---------------------- CONFIG ---------------------- */
/* Your project info (you gave this anon key earlier) */
const SUPABASE_URL = 'https://xvnbxdcqmfsnnvbugasi.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh2bmJ4ZGNxbWZzbm52YnVnYXNpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2OTE5NjIsImV4cCI6MjA3NjI2Nzk2Mn0.vQELSSzCZtFi8jXGWcc8Qn_PV0W_dpmd_R3nF3zg0H0';
/* Poll interval fallback (ms) */
const POLL_INTERVAL = 1000;
/* --------------------------------------------------- */

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* DOM */
const chatEl = document.getElementById('chat');
const usernameEl = document.getElementById('username');
const saveNameBtn = document.getElementById('saveName');
const currentUsernameLabel = document.getElementById('currentUsername');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');
const notice = document.getElementById('notice');

let currentUsername = localStorage.getItem('chatUsername') || '';
let pendingKey = 'chat_pending_v1';
let isRealtimeOk = false;
let lastMessagesHash = '';

/* init UI username */
if (currentUsername) {
  usernameEl.value = currentUsername;
  currentUsernameLabel.textContent = 'Username: ' + currentUsername;
} else {
  currentUsernameLabel.textContent = 'Username: Guest';
}

/* small helpers */
function escapeHtml(s){ return String(s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
function fmtTime(ts){
  try { return new Date(ts).toLocaleString(); } catch { return '??'; }
}
function showNotice(txt, ttl=2500){ notice.style.display = txt ? 'block' : 'none'; notice.textContent = txt || ''; if (ttl && txt) setTimeout(()=>{ if (notice.textContent===txt) notice.style.display='none'; }, ttl); }

/* pending queue helpers (offline sends) */
function getPending(){ return JSON.parse(localStorage.getItem(pendingKey) || '[]'); }
function savePending(a){ localStorage.setItem(pendingKey, JSON.stringify(a)); }
function addPending(obj){ const a=getPending(); a.push(obj); savePending(a); }
function removePending(obj){ const a = getPending().filter(x => JSON.stringify(x) !== JSON.stringify(obj)); savePending(a); }

/* render logic: preserve messageInput value during refresh */
function renderMessages(rows){
  // compute hash of message ids+updated timestamps to avoid re-render when same
  const hash = rows.map(r => `${r.id}:${r.created_at}`).join('|');
  if (hash === lastMessagesHash) return; // no change
  lastMessagesHash = hash;

  const inputVal = messageInput.value; // preserve typed text
  const scrollAtBottom = chatEl.scrollTop + chatEl.clientHeight >= chatEl.scrollHeight - 20;

  chatEl.innerHTML = '';
  rows.forEach(r => {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'message';
    rowDiv.dataset.id = r.id;
    rowDiv.innerHTML = `
      <div style="display:flex;align-items:center;gap:8px;flex:1">
        <div class="username">${escapeHtml(r.username)}</div>
        <div class="text">${escapeHtml(r.message)}</div>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <div class="meta ts">${escapeHtml(fmtTime(r.created_at))}</div>
      </div>
    `;
    // tiny delete button for your messages
    if (currentUsername && r.username === currentUsername) {
      const btn = document.createElement('button');
      btn.className = 'tiny-del';
      btn.title = 'Delete message';
      btn.textContent = '×';
      btn.style.width = '16px';
      btn.style.height = '16px';
      btn.style.fontSize = '12px';
      btn.style.marginLeft = '8px';
      btn.onclick = async (e) => {
        e.stopPropagation();
        // server-side delete
        try {
          const { error } = await supabase.from('messages').delete().eq('id', r.id);
          if (error) {
            console.error('Delete error', error);
            showNotice('Delete failed (check policies)');
            return;
          }
          // remove element immediately
          const el = chatEl.querySelector(`[data-id='${r.id}']`);
          if (el) el.remove();
        } catch (err) {
          console.error(err);
          showNotice('Delete failed');
        }
      };
      // append to rowDiv right side
      rowDiv.querySelector('div:last-child').appendChild(btn);
    }
    chatEl.appendChild(rowDiv);
  });

  if (scrollAtBottom) chatEl.scrollTop = chatEl.scrollHeight;
  messageInput.value = inputVal;
}

/* load messages from DB */
async function loadMessages(){
  try {
    const { data, error } = await supabase
      .from('messages')
      .select('id,username,message,created_at')
      .order('created_at', { ascending: true });
    if (error) { console.error('Load error', error); showNotice('Load failed'); return; }
    renderMessages(data || []);
  } catch (err) {
    console.error('Load exception', err);
    showNotice('Load failed');
  }
}

/* send message (with offline queue) */
async function sendMessage(){
  const txt = messageInput.value.trim();
  if (!txt) return;
  if (!currentUsername) { showNotice('Set username first'); return; }

  const row = { username: currentUsername, message: txt, created_at: new Date().toISOString() };

  if (!navigator.onLine) {
    addPending(row);
    // show pending in UI (optimistic)
    renderMessages([ ...(await fetchLatestForRender()), row ]);
    messageInput.value = '';
    showNotice('Offline — queued');
    return;
  }

  try {
    const { error } = await supabase.from('messages').insert([row]);
    if (error) {
      console.error('Insert error', error);
      addPending(row);
      showNotice('Insert failed — queued');
    } else {
      // success: reload
      await loadMessages();
    }
  } catch (err) {
    console.error('Send exception', err);
    addPending(row);
    showNotice('Send failed — queued');
  }
  messageInput.value = '';
}

/* fetch minimal latest rows for optimistic pending render */
async function fetchLatestForRender(){
  try {
    const { data } = await supabase.from('messages').select('id,username,message,created_at').order('created_at',{ascending:true});
    return data || [];
  } catch { return []; }
}

/* resend pending when back online */
async function resendPending(){
  const queue = getPending();
  if (!queue.length) return;
  for (const p of [...queue]) {
    try {
      const { error } = await supabase.from('messages').insert([{ username: p.username, message: p.message }]);
      if (!error) removePending(p);
    } catch (e) {
      console.error('resend error', e);
    }
  }
  await loadMessages();
}

/* Subscribe realtime (INSERT & DELETE). If fails, we rely on polling */
async function subscribeRealtime(){
  try {
    // clear previous channels
    await supabase.removeAllChannels();

    const channel = supabase
      .channel('realtime-messages')
      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {
        // payload.new is the inserted row
        // Efficient handling: if payload.new is already present we avoid heavy reload, but simplest: reload
        loadMessages();
      })
      .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'messages' }, payload => {
        // payload.old contains the deleted row
        const id = payload.old?.id;
        if (id) {
          const el = chatEl.querySelector(`[data-id='${id}']`);
          if (el) el.remove();
        }
      })
      .subscribe(async (status) => {
        // subscription status callback not always provided in older CDNs; we set flag conservatively
        // If subscription works, we will clear polling notice
        // We still keep polling as fallback
        if (status === 'SUBSCRIBED' || status === 'ONLINE') {
          isRealtimeOk = true;
          showNotice('');
        } else {
          // status might be an object in some builds; ignore
          // We'll rely on polling fallback
          isRealtimeOk = false;
        }
      });

    // If subscribe() throws, we'll catch
    isRealtimeOk = true;
    showNotice('');

  } catch (err) {
    console.warn('Realtime subscription failed, using polling fallback', err);
    isRealtimeOk = false;
    showNotice('Realtime unavailable — using 1s poll');
  }
}

/* UI wiring */
sendBtn.addEventListener('click', sendMessage);
messageInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendMessage(); });
saveNameBtn.addEventListener('click', () => {
  const name = usernameEl.value.trim();
  if (!name) return showNotice('Enter a username');
  currentUsername = name;
  localStorage.setItem('chatUsername', name);
  currentUsernameLabel.textContent = 'Username: ' + name;
});

/* Start: polling + realtime subscribe + resend pending */
(async function init(){
  await loadMessages();
  await subscribeRealtime();
  // Poll fallback every 1s
  setInterval(async () => {
    // if realtime working, still keep a light poll to ensure consistency
    await loadMessages();
  }, POLL_INTERVAL);

  // attempt resending pending queued messages when back online
  window.addEventListener('online', async () => { showNotice('Back online — sending queued messages...', 1500); await resendPending(); await loadMessages(); });
})();
</script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat App by Nishkarsh Rana</title>
  <script type="module" src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm"></script>
  <style>
    body { background:#0b1220; color:#e6eef8; font-family:Inter,system-ui,sans-serif; display:flex; justify-content:center; padding:18px;}
    .wrap { width:100%; max-width:720px;}
    h1 { text-align:center; color:#60a5fa; margin-bottom:10px;}
    .top { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; gap:8px;}
    #currentUsername { color:#94a3b8; font-size:0.95rem; margin-bottom:4px;}
    #username { background:#0f1724; color:#e6eef8; border:1px solid #1f2937; padding:6px 8px; border-radius:6px; width:48%;}
    #chat { background:#071127; border-radius:8px; padding:12px; height:287px; overflow-y:auto; border:1px solid #132033; margin-bottom:8px;}
    .message { margin-bottom:10px;}
    .username { color:#60a5fa; font-weight:700; margin-right:8px;}
    .ts { color:#94a3b8; font-size:0.82rem; margin-left:8px;}
    #controls { display:flex; gap:8px; margin-top:4px;}
    #messageInput { flex:1; padding:10px; border-radius:8px; background:#0f1724; color:#e6eef8; border:1px solid #1f2937;}
    button { border:none; border-radius:6px; cursor:pointer; }
    #sendBtn { background:#2563eb; color:white; padding:10px 14px;}
    #autoScrollBtn { background:#facc15; color:#1f2937; padding:8px 12px; font-size:0.85rem;}
    #deleteAllBtn { background:#dc2626; color:white; padding:8px 12px; font-size:0.85rem;}
    .pending { opacity:0.6; font-style:italic;}
    #status { position:fixed; right:14px; top:14px; padding:6px 10px; border-radius:8px; font-weight:788;}
    .online { background:#16a34a; color:#052e0b; } 
    .offline { background:#dc2626; color:#2b0202; }
    #nameMsg { color:#fb7185; font-size:0.9rem; margin-top:4px; min-height:1.2em;}
  </style>
</head>
<body>
  <div id="status" class="offline">Offline</div>
  <div class="wrap">
    <h1>Chat App — by Nishgamerr</h1>
    <div class="top">
      <div>
        <span id="currentUsername">Username: Guest</span><br>
        <input id="username" placeholder="Enter username or switch to previous">
        <button id="saveName">Save/Switch</button>
        <button id="autoScrollBtn">Auto-Scroll: On</button>
        <button id="deleteAllBtn">Delete All My Messages</button>
        <div id="nameMsg"></div>
      </div>
      <div style="color:#94a3b8">Old GUI • Realtime</div>
    </div>
    <div id="chat" role="log" aria-live="polite"></div>
    <div id="controls">
      <input id="messageInput" placeholder="Type a message">
      <button id="sendBtn">Send</button>
    </div>
  </div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

    const SUPABASE_URL = 'https://latrynkftllkwkesmohg.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxhdHJ5bmtmdGxsa3drZXNtb2hnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA4OTg5MzgsImV4cCI6MjA3NjQ3NDkzOH0.DBxC0tKd5axpldXK6CbKCR2rNqva-aerd_f985LTg0k';
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      realtime: {
        params: { eventsPerSecond: 100 }
      }
    });
// 👍👍👍👍👍👍t noob 🫂🫂🫂🫂🫂🫂🫂🫂🫂🫂 रहाफ़फ़फ़गगगगगग वववफसीसी फ़ cकॉल फ़रहासझझकग्गचग्जाफ्जफ्जड्जफ्जफ्जफ जक्ष्फग्ज्याकग्कफ्किफ्जजफजफफ्जफ्जफ्जजगजफव्जतुफ्जफ्जफ्जफ्जस्जव्जगजफजिव्जफन्दन्फन्वन्वन्सम्फकव्जस्जवजव जफ्जफ्जजगजग दजफ्जफ्जफ  कजफ्जफ जफ्फक्खजव्ज एहरुड़जफजड्जड्जददजज fjfjgjgjgkgkgkgmgmgkhchat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]fffffhttps://nish12345678910111.github.io/Nishgamerr.io/
    const chatEl = document.getElementById('chat');
    const usernameEl = document.getElementById('username');
    const saveNameBtn = document.getElementById('saveName');
    const currentUsernameLabel = document.getElementById('currentUsername');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const statusEl = document.getElementById('status');
    const autoScrollBtn = document.getElementById('autoScrollBtn');
    const deleteAllBtn = document.getElementById('deleteAllBtn');
    const nameMsgEl = document.getElementById('nameMsg');

    let currentUsername = localStorage.getItem('chatUsername') || 'Guest';
    let autoScroll = true;
    let clientIp = null;
    let isOnline = false;
    let statusTimeout = null;

    // --- FETCH CLIENT IP ---
    async function getClientIp() {
      try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        return data.ip;
      } catch (e) {
        console.error('Failed to fetch IP:', e);
        return 'unknown';
      }
    }

    // --- SAVE USERNAME TO IP ---
    async function saveUsernameToIp(ip, username) {
      try {
        const { error } = await supabase.from('user_ips').insert([{ ip_address: ip, username }]);
        if (error && error.code !== '23505') throw error;
      } catch (e) {
        console.error('Failed to save username to IP:', e);
      }
    }

    // --- LOAD USERNAMES FOR IP ---
    async function loadUsernamesForIp(ip) {
      try {
        const { data, error } = await supabase.from('user_ips').select('username').eq('ip_address', ip);
        if (error) throw error;
        return data.map(item => item.username);
      } catch (e) {
        console.error('Failed to load usernames for IP:', e);
        return [];
      }
    }

    // --- CHECK USERNAME AVAILABILITY ---
    async function isUsernameAvailable(username) {
      try {
        const { data, error } = await supabase.from('messages').select('username').eq('username', username).limit(1);
        if (error) throw error;
        return data.length === 0;
      } catch (e) {
        console.error('Error checking username:', e);
        return false;
      }
    }

    // --- UPDATE STATUS ---
    function updateStatus(status, className) {
      if (statusTimeout) clearTimeout(statusTimeout);
      statusTimeout = setTimeout(() => {
        if (statusEl.textContent !== status) {
          statusEl.textContent = status;
          statusEl.className = className;
          console.log(`Status updated: ${status}`);
        }
      }, 500);
    }

    // --- CHECK CONNECTIVITY ---
    async function checkConnectivity() {
      try {
        const { error } = await supabase.from('messages').select('id').limit(1);
        if (error) throw error;
        if (!isOnline) {
          updateStatus('Online', 'online');
          isOnline = true;
        }
      } catch (e) {
        updateStatus('Offline', 'offline');
        isOnline = false;
        console.error('Connectivity check failed:', e.message);
      }
    }

    // --- HELPERS ---
    function escapeHtml(s) { return String(s || '').replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    function fmtTime(ts) { const d = new Date(ts); return isNaN(d) ? '??:??' : d.toLocaleString(); }
    function flashNameMsg(txt) { nameMsgEl.textContent = txt; setTimeout(() => nameMsgEl.textContent = '', 2000); }

    // --- DISPLAY MESSAGE ---
    function addMessageRow(row, pending = false) {
      console.log('Adding message:', { ...row, pending });
      const existing = document.querySelector(`.message[data-temp-id='${row.tempId}']`) || document.querySelector(`.message[data-id='${row.id}']`);
      if (existing) {
        if (pending) return existing;
        existing.className = 'message';
        existing.dataset.id = row.id;
        delete existing.dataset.tempId;
        return existing;
      }
      const div = document.createElement('div');
      div.className = 'message' + (pending ? ' pending' : '');
      if (row.tempId) div.dataset.tempId = row.tempId;
      if (row.id) div.dataset.id = row.id;
      const delBtn = row.username === currentUsername ? ` <button class="delete-btn" data-id="${row.id || ''}">X</button>` : '';
      div.innerHTML = `<span class="username">${escapeHtml(row.username)}</span>: 
      <span class="text">${escapeHtml(row.message)}</span> 
      <span class="ts">[${fmtTime(row.created_at)}]</span>${delBtn}`;
      chatEl.appendChild(div);
      if (autoScroll) chatEl.scrollTop = chatEl.scrollHeight;

      if (delBtn) {
        const deleteBtn = div.querySelector('.delete-btn');
        deleteBtn.addEventListener('click', async () => {
          const messageId = div.dataset.id;
          console.log(`Attempting to delete message ID: ${messageId}`);
          try {
            const { error } = await supabase.from('messages').delete().eq('id', messageId).eq('username', currentUsername);
            if (error) throw error;
            console.log(`Deleted message ID: ${messageId}`);
            div.remove();
          } catch (e) {
            console.error('Delete error:', e.message);
            alert('Delete failed: ' + e.message);
          }
        });
      }
      return div;
    }

    // --- LOAD MESSAGES ---
    async function loadMessages() {
      try {
        const { data, error } = await supabase.from('messages')
          .select('*')
          .order('created_at', { ascending: true })
          .limit(50); // Optimize for speed
        if (error) throw error;
        const existingIds = new Set(Array.from(chatEl.querySelectorAll('.message')).map(el => el.dataset.id).filter(id => id));
        data.forEach(r => {
          if (!existingIds.has(r.id.toString())) {
            addMessageRow(r, false);
          }
        });
      } catch (e) {
        console.error('Load messages error:', e.message);
      }
    }

    // --- SEND MESSAGE ---
    async function sendMessage() {
      const txt = messageInput.value.trim();
      if (!txt) return;
      const tempId = Date.now().toString();
      const row = { username: currentUsername, message: txt, created_at: new Date().toISOString(), tempId };
      const messageDiv = addMessageRow(row, true);
      messageInput.value = '';
      try {
        const { data, error } = await supabase.from('messages').insert([{
          username: currentUsername,
          message: txt,
          created_at: row.created_at
        }]).select().single();
        if (error) throw error;
        messageDiv.className = 'message';
        messageDiv.dataset.id = data.id;
        delete messageDiv.dataset.tempId;
        await saveUsernameToIp(clientIp, currentUsername);
        console.log('Message confirmed:', data);
      } catch (e) {
        console.error('Send failed:', e.message);
        alert('Send failed: ' + e.message);
        messageDiv.remove();
      }
    }

    // --- AUTO SCROLL ---
    autoScrollBtn.addEventListener('click', () => {
      autoScroll = !autoScroll;
      autoScrollBtn.textContent = 'Auto-Scroll: ' + (autoScroll ? 'On' : 'Off');
    });

    // --- DELETE ALL ---
    deleteAllBtn.addEventListener('click', async () => {
      if (!confirm('Delete all your messages?')) return;
      try {
        const { error } = await supabase.from('messages').delete().eq('username', currentUsername);
        if (error) throw error;
        console.log('Deleted all messages for:', currentUsername);
        loadMessages();
      } catch (e) {
        console.error('Delete all error:', e.message);
        alert('Delete all failed: ' + e.message);
      }
    });

    // --- USERNAME ---
    saveNameBtn.addEventListener('click', async () => {
      const val = usernameEl.value.trim();
      if (!val) {
        flashNameMsg('Enter a username');
        return;
      }
      if (val === currentUsername) {
        flashNameMsg('Already using this username');
        return;
      }
      const prevUsernames = await loadUsernamesForIp(clientIp);
      if (prevUsernames.includes(val)) {
        currentUsername = val;
        localStorage.setItem('chatUsername', currentUsername);
        currentUsernameLabel.textContent = 'Username: ' + currentUsername;
        flashNameMsg('Switched to ' + val);
        loadMessages();
        usernameEl.value = '';
        return;
      }
      const isAvailable = await isUsernameAvailable(val);
      if (!isAvailable) {
        flashNameMsg('Username already taken');
        return;
      }
      currentUsername = val;
      localStorage.setItem('chatUsername', currentUsername);
      await saveUsernameToIp(clientIp, currentUsername);
      currentUsernameLabel.textContent = 'Username: ' + currentUsername;
      flashNameMsg('Username saved');
      loadMessages();
      usernameEl.value = '';
    });

    // --- ENTER KEY ---
    messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
    usernameEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') saveNameBtn.click();
    });

    // 🥰😭🥰🥰🥰🥰🥰🥰🥰🥰🥰🥰🥰ftyfufjfjfnfmgjgjgfjfjgjgugugugutututjgjgjgjgjggjjfchat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]chat: ⓡ︎ⓔ︎ⓐ︎ⓛ︎ ⓣ︎ⓘ︎ⓜ︎ⓔ︎ ⓒ︎ⓗ︎ⓐ︎ⓣ︎ [10/21/2025, 4:06:50 PM]
    // --- SEND BUTTON ---
    sendBtn.addEventListener('click', sendMessage);

    // --- REALTIME SUBSCRIPTION ---
    let channel = null;
    function subscribeToRealtime() {
      if (channel) {
        console.log('Removing existing channel');
        supabase.removeChannel(channel);
      }
      channel = supabase.channel('public:messages', {
        config: { broadcast: { ack: true } }
      })
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {
          console.log('Real-time INSERT:', payload);
          const row = payload.new;
          const existing = document.querySelector(`.message[data-temp-id]`) || document.querySelector(`.message[data-id='${row.id}']`);
          if (row.username !== currentUsername && !existing) {
            addMessageRow(row, false);
          } else if (existing && row.username === currentUsername) {
            existing.className = 'message';
            existing.dataset.id = row.id;
            delete existing.dataset.tempId;
          }
        })
        .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'messages' }, payload => {
          console.log('Real-time DELETE:', payload);
          const delId = payload.old.id;
          const el = document.querySelector(`.message[data-id='${delId}']`);
          if (el) el.remove();
        })
        .subscribe((status, err) => {
          console.log('Subscription status:', status, err ? err.message : '');
          if (status === 'SUBSCRIBED') {
            updateStatus('Online', 'online');
            isOnline = true;
            console.log('Real-time connected successfully');
          } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
            updateStatus('Offline', 'offline');
            isOnline = false;
            console.warn('Realtime disconnected. Retrying in 2s...');
            setTimeout(subscribeToRealtime, 2000);
          } else if (err) {
            console.error('Subscription error:', err.message);
            updateStatus('Offline', 'offline');
            isOnline = false;
          }
        });
    }
    subscribeToRealtime();

    // --- FALLBACK POLLING ---
    setInterval(() => {
      if (!isOnline) {
        console.log('Real-time inactive, polling for updates...');
        loadMessages();
        checkConnectivity();
      }
    }, 3000); // Faster polling for quicker updates

    // --- INITIAL LOAD ---
    async function init() {
      clientIp = await getClientIp();
      currentUsernameLabel.textContent = 'Username: ' + currentUsername;
      checkConnectivity();
      loadMessages();
    }
    init();
  </script>
</body>
  </html>
